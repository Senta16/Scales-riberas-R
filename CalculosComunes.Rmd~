---
title: "Cálculos comunes"
author: "María (modified by Indra)"
date: "inicio: 20 de octubre de 2016"
output: html_document
---
Last version: `r Sys.Date()`

```{r, echo=F}
library(knitr)
opts_knit$set(root.dir ="/home/indra/Dropbox/carpeta sin título/Datos_Indra")
# setwd("/home/indra/Dropbox/carpeta sin título/Datos_Indra")
ori.par <- par()
```

```{r set-options, echo=FALSE}
options(width = 1400)
```

# Load inputs
### Load packages
```{r loadpackages, tidy=T}
library(rgeos) # para calcular áreas etc
library(raster) # para importar shapefiles etc
library(rgdal) # para cambiar proyecciones de capas etc
library(vegan) # para calcular las riquezas
library(betapart) # para calcular betas
library(plyr) # para compactar resultados
```

### Load BASINS
```{r loadbasins, cache=T}
# make a list of all the files containing sites in the specified folder
fbas <- dir(path='GIS', pattern="basins.*shp", full.names=T)
# read all basins
basins <- lapply(fbas, shapefile, verbose=F)
# transform UTM data of polygons to longlat format
basins <- lapply(basins, function(scale){spTransform(scale, CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))})
```

### Load GEOBUFFERS
```{r loadgeos, cache=T}
# make a list of all the files containing sites in the specified folder
fgeo <- dir(path='GIS', pattern="geobuffers.*shp", full.names=T)
# read all basins
geos <- lapply(fgeo, shapefile, verbose=F)
# transform UTM data of polygons to longlat format
geos <- lapply(geos, function(scale){spTransform(scale, CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))})
```

### Load COSTMATRIX
```{r loadinventarios, cache=T}
cost <- read.table("costmatrix.csv", header=T, sep=",")
rownames(cost) <- colnames(cost)
cost.matrix <- as.matrix(cost)
```

### Load INVENTARIOS
```{r loadinventarios, cache=T}
inv.raw <- read.table("inventarios.csv", header=T, sep=",")
inv <- unique(inv.raw[,c("inv", "lon", "lat")])[,c("lon", "lat")]
ninv <- unique(inv.raw$inv)
rownames(inv) <- ninv
# transform numeric format of inventarios coordinates to spatial object
coordinates(inv) <- ~lon+lat
proj4string(inv) <- CRS("+proj=longlat +datum=WGS84")
```

### Load CLIMA
```{r loadclima, cache=T}
climest.raw <- read.table("clima.estaciones.csv", header=T, sep=",")
climest <- unique(climest.raw[,c("est", "lon", "lat")])[,c("lon", "lat")]
nclimest <- unique(climest.raw$est)
rownames(climest) <- nclimest
# transform numeric format of inventarios coordinates to spatial object
coordinates(climest) <- ~lon+lat
proj4string(climest) <- CRS("+proj=longlat +datum=WGS84")
```

### Load FUNCTIONS
```{r loadfunctions, cache=T, results="hide", message=F}
knitr::knit("/home/indra/Documents/20161001.scales.riberas/myscrhits/FuncionesCalculosComunes.Rmd")
```

# Calculate
### Select inventarios
```{r subinv, cache=T, dependson=c("loadfunctions", "loadinventarios", "loadbasins")}
# BASINS
inv.bas <- subset.points(basins, inv)
# GEOBUFFERS
inv.geo <- subset.points(geos, inv)
# COSTBUFFERS
# los costbuffers no se usan para filtrar, pq no existen poligonos
# se seleccionan los inventarios q están por debajo de cierta distancia de coste desde el inventario original

# SOLO PARA PROBAR
# elijo aleatoriamente el quantil del 12.5%
maxthresh <- quantile(c(cost.matrix), 0.06)
# thresholds <- 0.5+(1:8)*maxthresh/8
thresholds <- 0.5+(0.82-0.5)/8*(0:7)
inv.cos <- subset.cost(cost.matrix, thresholds)
```

### Create COST HULLS
```{r}
# NO existe AREA de los costbuffers, pq no existen poligonos
# construir convex hulls para hallar el área mínima q abarcan los inventarios
hulls.cos <- calc.ConvHull(inv.cos)
```

### Select datos climáticos
De momento solo de estaciones climáticas  
Pero para solventar los problemas de pools con pocos datos climáticos  
se propuso usar el clima medido en las coordenadas de los inventarios
```{r subcli, cache=T, dependson=c("loadfunctions", "loadclima", "loadbasins")}
# BASINS
cli.bas <- subset.points(basins, climest)
# GEOBUFFERS
cli.geo <- subset.points(geos, climest)
# COSTBUFFERS
# los costbuffers no se usan para filtrar, pq no existen poligonos
# se seleccionan las estaciones climáticas q están por debajo de cierta distancia de coste desde el inventario original
cli.cos <- subset.points(hulls.cos, climest)
```

### calc.RegRich(subinv)
```{r regrich, cache=T, dependson=c("loadfunctions", "subinv")}
invsp <- inv.raw[,c("inv", "sp")]
invtab <- table(invsp)
# BASINS
regrich.bas <- calc.RegRich(inv.bas)
# GEOBUFFERS
regrich.geo <- calc.RegRich(inv.geo)
# COSTBUFFERS
regrich.cos <- calc.RegRich(inv.cos)
```

### calculate Regional Area
```{r areas, message=F, cache=T, dependson=c("loadfunctions", "loadbasins", "loadgeos")}
# BASINS
area.bas <- calc.RegArea(basins)
# GEOBUFFERS
# hay un problema, no son IDENTICOS, solo parecidos!
area.geo <- calc.RegArea(geos)
# COSTBUFFERS
# NO existe AREA de los costbuffers, pq no existen poligonos
# por eso se usan convex hulls para hallar el área mínima q abarcan los inventarios
area.cos <- calc.RegArea(hulls.cos)
area.cos <- lapply(seq_along(area.cos), function(scale){
      dummy <- rep(NA, length(regrich.cos[[scale]]))
      dummy[1:662 %in% gsub("[1-8]\\.", "", hulls.cos[[scale]]@data$N)] <- area.cos[[scale]]
      return(dummy)
})
sapply(area.geo, median)
sapply(area.cos, median, na.rm=T)
```

### calc.LocRich(inv)
```{r locrich, cache=T, dependson=c("loadfunctions", "loadinventarios")}
# ALL 3 METHODS
LocRich <- calc.LocRich(inv.raw)
# la LocRich es independiente del RegPool
# es decir el método es irrelevante
```

# calc.intraBeta(subinv)
```{r intrabeta, cache=T, dependson=c("loadfunctions", "subinv")}
# BASINS
intrabeta.bas <- calc.intraBeta(inv.bas)
# GEOBUFFERS
intrabeta.geo <- calc.intraBeta(inv.geo)
# COSTBUFFERS
intrabeta.cos <- calc.intraBeta(inv.cos)
```

# calc.interBeta(subinv)
```{r interbeta, cache=T, dependson=c("loadfunctions", "subinv")}
# BASINS
interbeta.bas <- calc.interBeta(inv.bas)
# GEOBUFFERS
interbeta.geo <- calc.interBeta(inv.geo)
# COSTBUFFERS
interbeta.cos <- calc.interBeta(inv.cos)
```

### calc.RegClim(subclim)
```{r regclim, cache=T, dependson=c("loadfunctions", "subcli")}
# BASINS
regcli.bas <- calc.RegClim(cli.bas)
# GEOBUFFERS
regcli.geo <- calc.RegClim(cli.geo)
# COSTBUFFERS
regcli.cos <- calc.RegClim(cli.cos)
regcli.cos <- lapply(seq_along(regcli.cos), function(scale){
      dummy <- data.frame(matrix(rep(NA, ncol(regcli.cos[[1]])*length(regrich.cos[[scale]])), ncol=ncol(regcli.cos[[1]])))
      names(dummy) <- colnames(regcli.cos[[1]])
      dummy[1:662 %in% gsub("[1-8]\\.", "", hulls.cos[[scale]]@data$N),] <- regcli.cos[[scale]]
      return(dummy)
})
```



# compact.regional(pools, loc, areas, reg, cli, betaintra, betainter)
```{r results, cache=T, dependson=c("loadfunctions", "subinv", "locrich", "areas", "regrich", "subcli", "intrabeta", "interbeta")}
# BASINS
reg.bas <- compact.regional(areas=area.bas,
                              reg=regrich.bas,
                              cli=regcli.bas,
                              intrabeta=intrabeta.bas)

loc.bas <- compact.local(regrich.bas, inv.bas, LocRich, area.bas, regcli.bas)
# GEOBUFFERS
reg.geo <- compact.regional(areas=area.geo,
                              reg=regrich.geo,
                              cli=regcli.geo,
                              intrabeta=intrabeta.geo)

loc.geo <- compact.local(regrich.geo, inv.geo, LocRich, area.geo)
# COSTBUFFERS
reg.cos <- compact.regional(areas=area.cos,
                              reg=regrich.cos,
                              cli=regcli.cos,
                              intrabeta=intrabeta.cos)

loc.cos <- compact.local(regrich.cos, inv.cos, LocRich, area.cos, regcli.cos)
```

# EXPORT RESULTS! :)
```{r}
save(reg.bas, loc.bas, interbeta.bas, file = "res.basins.Rdata")
save(reg.geo, loc.geo, interbeta.geo, file = "res.geobuffers.Rdata")
save(reg.cos, loc.cos, interbeta.cos, file = "res.costbuffers.Rdata")
```